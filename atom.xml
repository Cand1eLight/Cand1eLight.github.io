<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>祝炩烟&#39;s Blog</title>
  
  <subtitle>会当身由己，婉转入江湖</subtitle>
  <link href="https://cand1elight.github.io/atom.xml" rel="self"/>
  
  <link href="https://cand1elight.github.io/"/>
  <updated>2025-03-16T14:30:30.245Z</updated>
  <id>https://cand1elight.github.io/</id>
  
  <author>
    <name>祝炩烟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第三周复盘|感受天地之势，我的笔，便与天地合一</title>
    <link href="https://cand1elight.github.io/posts/67946d22.html"/>
    <id>https://cand1elight.github.io/posts/67946d22.html</id>
    <published>2025-03-16T12:46:12.000Z</published>
    <updated>2025-03-16T14:30:30.245Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://204180371.xyz/PicGo/frieren-sousou-no-frieren-4k-wallpaper-uhdpaper.com-597@1@n.jpg" alt="分割线"></p><p>🔍 导航目录<br><a href="#学科总结">➤ 学科总结</a> | <a href="#时间分配">➤ 时间分配</a> | <a href="#下周计划">➤ 下周计划</a> | <a href="#箴言">➤ 本周箴言</a>  </p><h2 id="📚-学科总结"><a href="#📚-学科总结" class="headerlink" title="📚 学科总结"></a><span id="学科总结">📚 学科总结</span></h2><h3 id="📐-高等数学"><a href="#📐-高等数学" class="headerlink" title="📐 高等数学"></a>📐 高等数学</h3><p>这周关于高数确实是没有什么进展，写张宇的1000题感觉很多题目都不太写得动，而且一直错，这是最难受的，一直错，错多了就不想写了，课程不知道为什么听不进去，感觉学了和没有学一样，感觉很不好。</p><p>哈哈，似乎都是坏消息，但是也是有好消息的，积分的问题应该可以通过 积分大观来 完成进阶，而且我感觉帕拉说的很合理，张宇题目给的正反馈太少了，给我一种很憋屈的感觉。</p><p>我觉得下一周可以尝试一下武忠祥的课程，但是我又买了张宇26的书，感觉相较于25还是有进步的，至少1000题的重复率不是很高，也没有那么多的脑瘫题目。武忠祥的660倒是目前没有什么题目能够写，听到博主说880的题目质量好像比较高，我觉得下周可以试试。</p><p>张宇45年的这个确实是有些不太适应了，希望下周接触26的会有些好转，啊不对，下周是学习微分大观，虽然微分大观只有三四个小时，但是尽量每道题目都好好自己写一些，不知道是因为我看的题目比较简单时还是怎么回事，感觉up主讲得好快，而且前期的题目确实不是很复杂，还是花一些时间吧，毕竟都是真题，不存在偏难怪的情况，题目质量自然是比张宇的题目质量高一些的。</p><p>尽量三天内将积分大观完成学习吧，剩下的三天刷一下1000题，最后一天复习一下之前的660错题。加油，感觉帕拉说的方向很好</p><h3 id="🧠-数据结构"><a href="#🧠-数据结构" class="headerlink" title="🧠 数据结构"></a>🧠 数据结构</h3><p>本周数据结构确实是一种找到了感觉，但是很可惜本周没有和计划一样完成数据结构的学习，很可惜。</p><p>但是转念一想，如果为了赶上上周计划的进度，倒也不是不行，但是这样多少会有赶鸭子上架的念头，恐怕是没法将学习的完成度达到很高的，所以我还是决定稳扎稳打，下周周一将这一部分完成。</p><p>数据结构的进度也到末尾了，稍微总结一下吧，感觉数据结构写的很爽，甚至产生了像是依赖一样的东西，这也是拜高数所赐，因为高数实在是让我产生了抵触，高数的复杂晦涩难懂，毫无正反馈和数据结构产生明显的不同，数据结构给我一种只要学会思路就能够把题目写对的感觉，而且错的都是自己不会的，这种让自己查漏补缺的感觉很好，就好像是真的学到了东西，也了解到了正确的解法。</p><p>希望后续不管是计算机网络还是机组或者是操作系统都会给我这样的一种感觉，我觉得这种感觉很好，如果每门科目都能够以这种状态进行学习的话，我很肯定我会取得一个很好的成绩</p><p>本周确实找到了学习节奏📈，虽未按计划完成全部内容，但决定稳扎稳打：</p><ul><li>✅ 已掌握：树状结构遍历算法  </li><li>🔍 待加强：图论最短路径  </li><li>📅 计划完成：下周一收尾</li></ul><blockquote><p>💡 学习心得：<br>“数据结构给我一种只要学会思路就能够把题目写对的感觉，这种查漏补缺的体验就像在知识拼图中找到缺失的那一块”</p></blockquote><h3 id="🌍-英语"><a href="#🌍-英语" class="headerlink" title="🌍 英语"></a>🌍 英语</h3><p>说来惭愧，这周的英语时间实在是画的太少了，虽然嘴上说着不管考研英语圈的事情，但是多少感觉还是有些一些影响，感觉有点不想听田静的课程了，但是我觉得下周还是要听的，大概是这周蓝桥杯的准备时间挤压了英语的时间。</p><p>下周我决定每天来到自习室的第一件事情就是先完成当日英语的学习，对的，画一个小时，看半个小时语法，写半个小时阅读。因为说实话，英语并不是一个很难的板块，对我目前而言，所以作为每天的开始再好不过了。</p><p>不如就从简单开始，循序渐进的进入当天的学习。</p><p>📉 时间分配分析：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[语法]  ▰▰▰▱▱▱▱▱▱ 30%</span><br><span class="line">[阅读]  ▰▰▰▰▱▱▱▱▱ 40%</span><br><span class="line">[写作]  ▰▱▱▱▱▱▱▱▱ 10%</span><br></pre></td></tr></table></figure></p><p>🔔 改进方案：<br>⌛ 每日首个学习时段（建议8-9AM）专注英语<br>📌 使用番茄工作法（25分钟专注+5分钟休息）</p><h3 id="💻-蓝桥杯备赛"><a href="#💻-蓝桥杯备赛" class="headerlink" title="💻 蓝桥杯备赛"></a>💻 蓝桥杯备赛</h3><p>这个星期确实投入了远超上周的时间，还是在慢慢啃前期的东西，简单的东西，我觉得过了暴力的话后续的东西内容方面会缩减很多，不会在和现在一样花时间，主要现在每次搞懂一道题目都会画很多时间，包括问AI，或者自己理解代码的思维。但我相信，这种东西是有积累的，越到后面想必学的会越来越快。</p><p>加油，下周至少学完两个pdf吧，不算上目前暴力的pdf，感觉暴力的pdf后面东西不会很多了，加油。</p><p>📊 本周投入分布：<br>| 算法类型 | 时间占比 | 掌握程度 |<br>|————-|————|————-|<br>| 暴力破解 | 60%    | ▰▰▰▰▰   |<br>| DFS/BFS | 25%    | ▰▰▱▱▱   |<br>| 动态规划 | 15%    | ▰▱▱▱▱   |</p><p>🚀 下周目标：<br>完成两个专题PDF学习（图论+贪心算法）</p><h2 id="🌟-本周箴言"><a href="#🌟-本周箴言" class="headerlink" title="🌟 本周箴言"></a><span id="箴言">🌟 本周箴言</span></h2><blockquote><p>📌 “慢即是快，少即是多”<br>🔥 核心认知：<br>知识积累如同溪流汇海，看似缓慢的每日进步终将汇聚成磅礴的知识海洋🌊</p></blockquote><style>.progress {  height: 20px;  background-color: #f5f5f5;  border-radius: 10px;  margin: 15px 0;}.progress-bar {  height: 100%;  background: linear-gradient(90deg, #6c5ce7, #a8a4e6);  border-radius: 10px;  text-align: right;  padding-right: 10px;  color: white;  font-size: 12px;  line-height: 20px;}</style>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://204180371.xyz/PicGo/frieren-sousou-no-frieren-4k-wallpaper-uhdpaper.com-597@1@n.jpg&quot; alt=&quot;分割线&quot;&gt;&lt;/p&gt;
&lt;p&gt;🔍 导航目录&lt;br&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="考研" scheme="https://cand1elight.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="复盘" scheme="https://cand1elight.github.io/tags/%E5%A4%8D%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯题目|全球变暖 dfs解法思路分享</title>
    <link href="https://cand1elight.github.io/posts/c563ecfe.html"/>
    <id>https://cand1elight.github.io/posts/c563ecfe.html</id>
    <published>2025-03-15T09:20:08.000Z</published>
    <updated>2025-03-15T09:33:21.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🌍-全球变暖问题：岛屿淹没统计-深度优先搜索实战"><a href="#🌍-全球变暖问题：岛屿淹没统计-深度优先搜索实战" class="headerlink" title="🌍 全球变暖问题：岛屿淹没统计 | 深度优先搜索实战"></a>🌍 全球变暖问题：岛屿淹没统计 | 深度优先搜索实战</h1><hr><h2 id="🎯-问题描述"><a href="#🎯-问题描述" class="headerlink" title="🎯 问题描述 "></a>🎯 问题描述 <a name="问题描述"></a></h2><p>给定一个 <code>N×N</code> 的海域照片，其中：</p><ul><li><code>.</code> 表示海洋</li><li><code>#</code> 表示陆地</li></ul><p>当一个岛屿（连通陆地）<strong>所有陆地像素</strong>的上下左右相邻位置中都至少有一个是海洋时，该岛屿会被完全淹没。要求统计会被完全淹没的岛屿数量。</p><p><strong>输入示例</strong>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">.......</span><br><span class="line">.##....</span><br><span class="line">.##....</span><br><span class="line">....##.</span><br><span class="line">..####.</span><br><span class="line">...###.</span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p><p>博主初看的时候看错题目了，我以为图中计算的是还有多少的<strong>陆地像素留下</strong>，结果最后才发现计算的是有<strong>多少个岛屿沉没了</strong>🥲<br>所以这个代码的思路是一个个的遍历图中的每一个节点，如果遍历过了就打上标记（v[x][y] = 1），并且先假设这个像素是安全的，然后遍历这个像素的上下左右四个节点，如果是安全的就将safe设置为1，然后接着递归的通过dfs搜索其四周的像素，只要有一个像素是安全的就说明这个岛屿不会沉没，不算在最后的结果中，但是如果迭代到最后safe都是0，则说明这个岛屿会沉没。</p><h2 id="🧠-解题思路"><a href="#🧠-解题思路" class="headerlink" title="🧠 解题思路 "></a>🧠 解题思路 <a name="解题思路"></a></h2><h3 id="双关键步骤解析"><a href="#双关键步骤解析" class="headerlink" title="双关键步骤解析"></a>双关键步骤解析</h3><ol><li><p><strong>岛屿遍历策略</strong> 🗺️</p><ul><li>使用 <strong>深度优先搜索(DFS)</strong> 遍历每个未访问的陆地像素</li><li>通过标记矩阵记录已访问区域，避免重复计算</li></ul></li><li><p><strong>淹没判定逻辑</strong> 🔍</p><ul><li>对每个陆地像素进行四方向海洋检测</li><li><strong>关键判断</strong>：只要存在一个陆地像素四面临陆，则整个岛屿不会被淹没</li></ul></li></ol><hr><h2 id="🖥️-代码实现"><a href="#🖥️-代码实现" class="headerlink" title="🖥️ 代码实现 "></a>🖥️ 代码实现 <a name="代码实现"></a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义矩阵的边长</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">// 存储海域矩阵，&#x27;.&#x27; 表示海洋，&#x27;#&#x27; 表示陆地</span></span><br><span class="line"><span class="type">char</span> m[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="comment">// 标记矩阵，用于记录每个位置是否已经被访问过</span></span><br><span class="line"><span class="type">int</span> v[<span class="number">1010</span>][<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 定义四个方向的偏移量，分别为右、左、下、上</span></span><br><span class="line"><span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 标记当前岛屿是否存在安全的陆地，0 表示不存在，1 表示存在</span></span><br><span class="line"><span class="type">int</span> safe;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查坐标 (x, y) 是否在合法范围内（矩阵内）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索函数，用于遍历一个岛屿</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记当前位置 (x, y) 为已访问</span></span><br><span class="line">    v[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 假设当前陆地是安全的，即不会被淹没</span></span><br><span class="line">    <span class="type">bool</span> issafe = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前陆地的上下左右四个相邻位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算相邻位置的坐标</span></span><br><span class="line">        <span class="type">int</span> nx = x + d[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ny = y + d[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 检查相邻位置是否在合法范围内且为海洋</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(nx, ny) &amp;&amp; m[nx][ny] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果相邻位置是海洋，说明当前陆地不安全</span></span><br><span class="line">            issafe = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 只要有一个相邻位置是海洋，就不用继续检查其他相邻位置了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前陆地是安全的，说明该岛屿存在安全的陆地</span></span><br><span class="line">    <span class="keyword">if</span> (issafe) &#123;</span><br><span class="line">        <span class="comment">// 将 safe 标记为 1，表示该岛屿不会被完全淹没</span></span><br><span class="line">        safe = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续递归搜索当前陆地的上下左右四个相邻陆地</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算相邻位置的坐标</span></span><br><span class="line">        <span class="type">int</span> nx = x + d[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ny = y + d[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 检查相邻位置是否在合法范围内、未被访问过且为陆地</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(nx, ny) &amp;&amp; m[nx][ny] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; v[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归调用 dfs 函数，继续搜索该相邻陆地所在的岛屿</span></span><br><span class="line">            <span class="built_in">dfs</span>(nx, ny);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取矩阵的边长</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 读取海域矩阵的每一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cin &gt;&gt; m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于统计会被完全淹没的岛屿数量</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历整个海域矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">// 找到未被访问过的陆地</span></span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; v[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 假设当前岛屿会被完全淹没，将 safe 初始化为 0</span></span><br><span class="line">                safe = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 从当前陆地开始进行深度优先搜索，遍历整个岛屿</span></span><br><span class="line">                <span class="built_in">dfs</span>(i, j);</span><br><span class="line">                <span class="comment">// 如果遍历完整个岛屿后 safe 仍然为 0，说明该岛屿没有安全的陆地，会被完全淹没</span></span><br><span class="line">                <span class="keyword">if</span> (safe == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 会被完全淹没的岛屿数量加 1</span></span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出会被完全淹没的岛屿数量</span></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="📊-复杂度分析"><a href="#📊-复杂度分析" class="headerlink" title="📊 复杂度分析 "></a>📊 复杂度分析 <a name="复杂度分析"></a></h2><div class="table-container"><table><thead><tr><th>维度</th><th>复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>时间复杂度</strong></td><td>O(N²)</td><td>每个网格节点访问一次</td></tr><tr><td><strong>空间复杂度</strong></td><td>O(N²)</td><td>存储访问标记矩阵</td></tr><tr><td><strong>最优情况</strong></td><td>Ω(N²)</td><td>必须遍历所有节点</td></tr></tbody></table></div><hr><h2 id="🔍-测试用例"><a href="#🔍-测试用例" class="headerlink" title="🔍 测试用例 "></a>🔍 测试用例 <a name="测试用例"></a></h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">.......</span><br><span class="line">.##....</span><br><span class="line">.##....</span><br><span class="line">....##.</span><br><span class="line">..####.</span><br><span class="line">...###.</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><h1 id="AC结果图"><a href="#AC结果图" class="headerlink" title="AC结果图"></a>AC结果图</h1><p><img src="https://204180371.xyz/PicGo/20250315173029010.png" alt=""></p><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="图示说明"><a href="#图示说明" class="headerlink" title="图示说明"></a>图示说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">初始海域：</span><br><span class="line">.......</span><br><span class="line">.##.... → 存在岛屿</span><br><span class="line">.##....</span><br><span class="line">....##.</span><br><span class="line">..####. → 存在中心安全陆地</span><br><span class="line">...###.</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">输出说明：</span><br><span class="line">只有中心岛屿存在安全陆地，其他岛屿都会被淹没</span><br></pre></td></tr></table></figure><hr><h2 id="❓-常见问题"><a href="#❓-常见问题" class="headerlink" title="❓ 常见问题 "></a>❓ 常见问题 <a name="常见问题与注意事项"></a></h2><h3 id="Q1：如何处理边界情况？"><a href="#Q1：如何处理边界情况？" class="headerlink" title="Q1：如何处理边界情况？"></a>Q1：如何处理边界情况？</h3><p><strong>A</strong>: 使用在条件判断中严格检查坐标合法性，防止数组越界，越界的话也是过不了样例的😭</p><h3 id="Q2：为什么使用全局变量？"><a href="#Q2：为什么使用全局变量？" class="headerlink" title="Q2：为什么使用全局变量？"></a>Q2：为什么使用全局变量？</h3><p><strong>A</strong>: 简化DFS参数传递，但需要注意多测试用例时的重置问题</p><h3 id="Q3：算法优化方向？"><a href="#Q3：算法优化方向？" class="headerlink" title="Q3：算法优化方向？"></a>Q3：算法优化方向？</h3><ul><li><strong>并行处理</strong>：对独立岛屿进行并行DFS</li><li><strong>空间优化</strong>：使用位压缩存储访问标记</li></ul><hr><h2 id="🏆-总结"><a href="#🏆-总结" class="headerlink" title="🏆 总结 "></a>🏆 总结 <a name="总结"></a></h2><ol><li><strong>核心技巧</strong>：DFS遍历 + 四方向安全检测</li><li><strong>易错点</strong>：<ul><li>边界条件处理</li><li>岛屿连通性判断</li></ul></li><li><strong>扩展应用</strong>：该算法框架可应用于其他连通区域分析问题</li></ol><hr><h1 id="希望对你有所帮助"><a href="#希望对你有所帮助" class="headerlink" title="希望对你有所帮助"></a>希望对你有所帮助</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🌍-全球变暖问题：岛屿淹没统计-深度优先搜索实战&quot;&gt;&lt;a href=&quot;#🌍-全球变暖问题：岛屿淹没统计-深度优先搜索实战&quot; class=&quot;headerlink&quot; title=&quot;🌍 全球变暖问题：岛屿淹没统计 | 深度优先搜索实战&quot;&gt;&lt;/a&gt;🌍 全球变暖问题</summary>
      
    
    
    
    
    <category term="算法" scheme="https://cand1elight.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="蓝桥杯" scheme="https://cand1elight.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>第二周复盘|听不到世界的声音，就是和自身交流</title>
    <link href="https://cand1elight.github.io/posts/e23ea06e.html"/>
    <id>https://cand1elight.github.io/posts/e23ea06e.html</id>
    <published>2025-03-09T12:55:25.000Z</published>
    <updated>2025-03-09T13:01:56.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📚第二周复盘-听不到世界的声音，就是和自身交流🎉✨"><a href="#📚第二周复盘-听不到世界的声音，就是和自身交流🎉✨" class="headerlink" title="📚第二周复盘|听不到世界的声音，就是和自身交流🎉✨"></a>📚第二周复盘|听不到世界的声音，就是和自身交流🎉✨</h1><p><img src="https://204180371.xyz/PicGo/20250309205801661.png" alt="学习封面"><br><em><center>🕰️ 2025-03-09 | 📌 标签：#考研 #复盘 </center></em></p><hr><h2 id="高等数学-🧮"><a href="#高等数学-🧮" class="headerlink" title="高等数学 🧮"></a>高等数学 🧮</h2><p><strong>本周学习情况:</strong> 本周主要精力放在刷题上! 虽然已经学习了基础数学，但解题能力并没有显著提高，看来刷题需要长期积累! 🤔</p><p><strong>目标与计划:</strong> 目前能够应付基础660题，但1000题的套路还没完全掌握。打算先从最新版本的660题入手，逐步提升解题能力! 💪  刷题效率有待提高，目前还处于基础阶段! 🌱</p><p><strong>学习方法:</strong>  如果10分钟内解不出题，就看答案，并分析解题思路! 💡 错题要在10分钟内重新做出来! ✍️</p><hr><h2 id="数据结构-💻"><a href="#数据结构-💻" class="headerlink" title="数据结构 💻"></a>数据结构 💻</h2><p><strong>学习感受:</strong> 数据结构的学习让我感到非常愉悦! 😄就像高中时期学习生物一样，感觉很轻松，也很享受这个过程，仿佛进入了心流状态! 🧘‍♀️ <br> 几乎每道题都能独立完成，感觉不复杂，写起来很舒服! 😊</p><p><strong>下周计划:</strong> 下周争取完成数据结构部分! 加油! 💪</p><hr><h2 id="英语-📚"><a href="#英语-📚" class="headerlink" title="英语 📚"></a>英语 📚</h2><p><strong>基础语法:</strong> 田静老师的基础语法确实太简单了，对于我来说，速通简单句部分完全没问题! 😎</p><p><strong>下周计划:</strong> 下周开始学习长难句，增加阅读量到每天两篇! 📖  如果强度仍然不够，我会考虑限制做题时间，提升解题速度! ⏱️</p><p><strong>问题与改进:</strong> 目前解题速度较慢，总是追求最稳妥的答案，导致花费时间较长。需要进行限时训练! ⏰</p><hr><h2 id="下周学习计划-🗓️"><a href="#下周学习计划-🗓️" class="headerlink" title="下周学习计划 🗓️"></a>下周学习计划 🗓️</h2><p><strong>时间规划:</strong>  第一周对时间安排不太清晰，但这周我对时间消耗有了更准确的认识。下周要根据时间合理规划学习内容! 🤓  <br>如果没有课程，每天至少学习8小时（包含30分钟的通勤时间），每多一节课减少半小时学习时间。</p><p><strong>每日安排:</strong> 每天早上计划好当天的学习内容! 📝</p><hr><h2 id="蓝桥杯-🏆"><a href="#蓝桥杯-🏆" class="headerlink" title="蓝桥杯 🏆"></a>蓝桥杯 🏆</h2><p><strong>学习资源:</strong> 我已经找到了相关的速成课程! 👍</p><p><strong>学习时间:</strong> 为了取得好成绩，每天至少学习2小时，安排在晚上! 🌃</p><p><strong>每日安排:</strong> 上午高等数学，下午数据结构，晚上蓝桥杯和英语，晚上也安排高等数学的补习时间! 🤓</p><hr><h2 id="最后的思考-🤔"><a href="#最后的思考-🤔" class="headerlink" title="最后的思考 🤔"></a>最后的思考 🤔</h2><blockquote><p>上周学习的主题是宫本武藏，本周借用佐佐木小次郎的经历来激励自己!  🔥佐佐木小次郎是一位天才剑客，天生聋哑，却能专注于剑道，进入心流状态! 🧘‍♂️ <br> 为了提高效率，下周我会改变学习习惯，不再边听歌边刷题，只听纯音乐或不听音乐，只有休息时才听一首歌! 🎶 期待下周能够高效学习! 🚀</p></blockquote><hr><p style="text-align: right;">希望这个总结能够帮助我更好地规划接下来的学习，也希望能够持续保持高效的学习状态!  ✨</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;📚第二周复盘-听不到世界的声音，就是和自身交流🎉✨&quot;&gt;&lt;a href=&quot;#📚第二周复盘-听不到世界的声音，就是和自身交流🎉✨&quot; class=&quot;headerlink&quot; title=&quot;📚第二周复盘|听不到世界的声音，就是和自身交流🎉✨&quot;&gt;&lt;/a&gt;📚第二周</summary>
      
    
    
    
    
    <category term="考研" scheme="https://cand1elight.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="复盘" scheme="https://cand1elight.github.io/tags/%E5%A4%8D%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>第一周复盘 | 心如果被吸引，手上的剑就挥不出</title>
    <link href="https://cand1elight.github.io/posts/b1980b8a.html"/>
    <id>https://cand1elight.github.io/posts/b1980b8a.html</id>
    <published>2025-03-03T10:04:43.000Z</published>
    <updated>2025-03-03T11:23:40.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📚-第一周复盘-心如果被吸引，手上的剑就挥不出"><a href="#📚-第一周复盘-心如果被吸引，手上的剑就挥不出" class="headerlink" title="📚 第一周复盘 | 心如果被吸引，手上的剑就挥不出"></a>📚 第一周复盘 | 心如果被吸引，手上的剑就挥不出</h1><p><img src="https://204180371.xyz/PicGo/b02e629a3e74d0c1b618d1d292e6d780_720.jpeg" alt="学习封面"><br><em><center>🕰️ 2025-01-30 | 📌 标签：#考研 #复盘 #时间管理</center></em></p><hr><h2 id="📌-本周进展"><a href="#📌-本周进展" class="headerlink" title="📌 本周进展"></a>📌 本周进展</h2><h3 id="📐-高等数学"><a href="#📐-高等数学" class="headerlink" title="📐 高等数学"></a>📐 高等数学</h3><ul><li>✅ 完成第九章内容汇总</li><li>📖 武忠祥教材 &amp; 张宇讲义双线推进</li><li>🚩 下周重点：积分大题突破（武忠祥基础题未覆盖部分）</li></ul><h3 id="📖-英语攻坚"><a href="#📖-英语攻坚" class="headerlink" title="📖 英语攻坚"></a>📖 英语攻坚</h3><ul><li>🧠 每日20新词 + 滚动复习</li><li>🚶♂️ 碎片化学习：通勤/就餐背单词</li><li>📘《句句真研》进度：4天35页 → 周目标60页（三月完结全书）</li></ul><h3 id="💻-数据结构（408）"><a href="#💻-数据结构（408）" class="headerlink" title="💻 数据结构（408）"></a>💻 数据结构（408）</h3><ul><li>🎯 当前进度：50%核心内容</li><li>📅 二轮计划：重点突破大题</li><li>🔥 目标：3月中旬完成一轮小题复习</li></ul><hr><h2 id="🏆-蓝桥杯备战"><a href="#🏆-蓝桥杯备战" class="headerlink" title="🏆 蓝桥杯备战"></a>🏆 蓝桥杯备战</h2><ul><li>⚙️ 启动系统性刷题</li><li>🕒 剩余时间：30天</li><li>💡 策略：保持每日高强度训练</li></ul><hr><h2 id="🔧-项目进展"><a href="#🔧-项目进展" class="headerlink" title="🔧 项目进展"></a>🔧 项目进展</h2><ul><li>✅ 上交项目阶段暂时告一段落</li><li>张老师还是很开明的，希望最后考研能取得一个好的成果，最后也能和张老师学更多东西。</li></ul><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>结语的话就用刷到的抖音里面的演讲的一句话结束吧，割麦子之所以割的快，是因为弯腰从不直起来，一直弯着腰割着稻草，自然就会很快，有一次直起来，就会有无数次直起来，所以，把腰一直弯下去吧，当把腰直起来的时候，就回不去了。</p><h2 id="💭-本周思考"><a href="#💭-本周思考" class="headerlink" title="💭 本周思考"></a>💭 本周思考</h2><blockquote><p>🌾 <strong>割麦哲学</strong><br>“弯腰的节奏决定收割速度，<br>直腰的诱惑如同复习时的分心，<br>一次妥协就会形成惯性。<br>真正的专注是把调试状态成本归零。”</p></blockquote><center>✨ 保持弓弦满月的状态，直到箭矢破空而出 ✨</center>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;📚-第一周复盘-心如果被吸引，手上的剑就挥不出&quot;&gt;&lt;a href=&quot;#📚-第一周复盘-心如果被吸引，手上的剑就挥不出&quot; class=&quot;headerlink&quot; title=&quot;📚 第一周复盘 | 心如果被吸引，手上的剑就挥不出&quot;&gt;&lt;/a&gt;📚 第一周复盘 | 心</summary>
      
    
    
    
    
    <category term="考研" scheme="https://cand1elight.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="复盘" scheme="https://cand1elight.github.io/tags/%E5%A4%8D%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Acwing 字符串章末数题总结</title>
    <link href="https://cand1elight.github.io/posts/56b22553.html"/>
    <id>https://cand1elight.github.io/posts/56b22553.html</id>
    <published>2025-01-31T15:38:34.000Z</published>
    <updated>2025-03-03T11:23:50.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📝-题目-1：字符串的最小乘方单位"><a href="#📝-题目-1：字符串的最小乘方单位" class="headerlink" title="📝 题目 1：字符串的最小乘方单位"></a>📝 题目 1：字符串的最小乘方单位</h2><h3 id="📌-题目解析"><a href="#📌-题目解析" class="headerlink" title="📌 题目解析"></a>📌 题目解析</h3><p>上述代码用于求解 <strong>字符串的乘方</strong>，计算字符串的 <strong>最小乘方单位</strong>，即判断字符串是否由某个子串重复若干次构成，并找出最大的重复次数。</p><h3 id="💡-代码实现"><a href="#💡-代码实现" class="headerlink" title="💡 代码实现"></a>💡 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &amp;&amp; a != <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n = len;n;n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len % n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> m = len / n;</span><br><span class="line">                string s = a.<span class="built_in">substr</span>(<span class="number">0</span>,m);</span><br><span class="line">                string str;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) </span><br><span class="line">                    str += s;</span><br><span class="line">                <span class="keyword">if</span>(str == a)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🔍-代码思路"><a href="#🔍-代码思路" class="headerlink" title="🔍 代码思路"></a>🔍 代码思路</h3><ol><li><strong>循环读取输入字符串</strong>，直到输入的字符串为 <code>&quot;.&quot;</code> 结束。</li><li><strong>获取字符串长度 <code>len</code></strong>，然后从 <code>len</code> 开始倒序遍历，找到最大的 <code>n</code>，使得 <code>len</code> 能被 <code>n</code> 整除。</li><li><strong>计算 <code>m = len / n</code></strong>，即每个重复单元的长度（从 <code>1</code> 开始，逐步增加）。</li><li><strong>提取字符串的前 <code>m</code> 个字符</strong> 作为重复单元 <code>s</code>。</li><li><strong>构造新字符串 <code>str</code></strong>，用 <code>s</code> <strong>重复 <code>n</code> 次</strong> 进行匹配。</li><li><strong>判断 <code>str</code> 是否等于 <code>a</code></strong>，如果相等，则 <code>n</code> 即为最大周期，输出 <code>n</code> 并终止循环。</li><li><strong>遍历方式</strong>：<ul><li><strong>外层循环</strong> 负责找 <code>n</code>，从最大可能的周期开始，保证找到的是<strong>最大的 <code>n</code></strong>。</li><li><strong>内层循环</strong> 负责构造 <code>str</code>，确保 <code>str</code> 是否与 <code>a</code> 一致。</li></ul></li></ol><h3 id="🚀-示例测试"><a href="#🚀-示例测试" class="headerlink" title="🚀 示例测试"></a>🚀 示例测试</h3><div class="table-container"><table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td><code>abab</code></td><td><code>2</code></td></tr><tr><td><code>aaaa</code></td><td><code>4</code></td></tr><tr><td><code>abcabcabc</code></td><td><code>3</code></td></tr></tbody></table></div><h3 id="✨-代码优化"><a href="#✨-代码优化" class="headerlink" title="✨ 代码优化"></a>✨ 代码优化</h3><ul><li><strong>从 <code>len</code> 开始遍历 <code>n</code></strong>，保证找到<strong>最大的 <code>n</code></strong>。</li><li><strong>整除判断优化</strong>，只对 <code>len</code> 可被 <code>n</code> 整除的 <code>n</code> 进行检测，减少无效计算。</li><li><strong>更高效方案</strong>（如 <code>KMP</code>），可用 <code>next</code> 数组快速找到最小循环单位。</li></ul><hr><h2 id="📝-题目-2：求解字符串之间的最大距离"><a href="#📝-题目-2：求解字符串之间的最大距离" class="headerlink" title="📝 题目 2：求解字符串之间的最大距离"></a>📝 题目 2：求解字符串之间的最大距离</h2><h3 id="📌-题目解析-1"><a href="#📌-题目解析-1" class="headerlink" title="📌 题目解析"></a>📌 题目解析</h3><p>本题的目标是 <strong>求解两个子串 <code>s1</code> 和 <code>s2</code> 在 <code>s</code> 中出现的最远间隔</strong>，即 <code>s1</code> 在 <code>s</code> 中的最早出现位置 <code>l</code>，<code>s2</code> 在 <code>s</code> 中的最晚出现位置 <code>r</code>，求 <code>r - l - 1</code>。</p><h3 id="💡-代码实现-1"><a href="#💡-代码实现-1" class="headerlink" title="💡 代码实现"></a>💡 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    string s, s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取字符串</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c, c != <span class="string">&#x27;,&#x27;</span>) s += c;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c, c != <span class="string">&#x27;,&#x27;</span>) s1 += c;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s2);  <span class="comment">// ✅ 解决终端卡住的问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 s 的长度小于 s1 或 s2，直接返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; s<span class="number">1.</span><span class="built_in">size</span>() || s.<span class="built_in">size</span>() &lt; s<span class="number">2.</span><span class="built_in">size</span>())</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到 s1 在 s 中的起始位置</span></span><br><span class="line">        <span class="keyword">while</span> (l + s<span class="number">1.</span><span class="built_in">size</span>() &lt;= s.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; s<span class="number">1.</span><span class="built_in">size</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[k + l] != s1[k])  <span class="comment">// ✅ 修正索引</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == s<span class="number">1.</span><span class="built_in">size</span>())  <span class="comment">// 如果匹配完整 s1</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r = s.<span class="built_in">size</span>() - s<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 找到 s2 在 s 中的末尾匹配位置</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; s<span class="number">2.</span><span class="built_in">size</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[r + k] != s2[k]) <span class="comment">// ✅ 修正索引</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == s<span class="number">2.</span><span class="built_in">size</span>())  <span class="comment">// 如果匹配完整 s2</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l += s<span class="number">1.</span><span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// 调整 l 位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算中间间隔</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r - l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🔍-代码思路-1"><a href="#🔍-代码思路-1" class="headerlink" title="🔍 代码思路"></a>🔍 代码思路</h3><ol><li><strong>读取字符串 <code>s</code></strong>，子串 <code>s1</code> 和 <code>s2</code>。</li><li><strong>边界条件判断</strong>：<ul><li>如果 <code>s</code> 的长度 <strong>小于 <code>s1</code> 或 <code>s2</code></strong>，直接输出 <code>-1</code>。</li></ul></li><li><strong>寻找 <code>s1</code> 在 <code>s</code> 中的起始位置 <code>l</code></strong>：<ul><li>从 <code>0</code> 开始遍历 <code>s</code>，找到 <code>s1</code> <strong>首次匹配的位置</strong>。</li><li>通过 <code>while</code> 循环和 <code>k</code> 变量 <strong>检测子串是否匹配</strong>。</li></ul></li><li><strong>寻找 <code>s2</code> 在 <code>s</code> 中的末尾位置 <code>r</code></strong>：<ul><li>从 <code>s.size() - s2.size()</code> 开始倒序遍历 <code>s</code>，找到 <code>s2</code> <strong>最后一次出现的位置</strong>。</li></ul></li><li><strong>计算最终距离</strong>：<ul><li>由于 <code>l</code> 记录的是 <code>s1</code> 的 <strong>起始位置</strong>，因此 <code>l += s1.size() - 1</code> 进行调整。</li><li>计算 <code>r - l - 1</code>，如果 <code>l &gt;= r</code>，说明 <code>s1</code> 在 <code>s2</code> 之后或二者重叠，输出 <code>-1</code>，否则输出 <strong>最大距离</strong>。</li></ul></li></ol><h3 id="🚀-示例测试-1"><a href="#🚀-示例测试-1" class="headerlink" title="🚀 示例测试"></a>🚀 示例测试</h3><div class="table-container"><table><thead><tr><th>输入</th><th>输出</th></tr></thead><tbody><tr><td><code>abcde,bc,d</code></td><td><code>1</code></td></tr><tr><td><code>helloworld,hello,world</code></td><td><code>0</code></td></tr><tr><td><code>abcabcabc,abc,c</code></td><td><code>4</code></td></tr><tr><td><code>abc,abcd,xyz</code></td><td><code>-1</code></td></tr></tbody></table></div><h3 id="✨-代码优化-1"><a href="#✨-代码优化-1" class="headerlink" title="✨ 代码优化"></a>✨ 代码优化</h3><ul><li><strong>提前判断 <code>s1</code> 和 <code>s2</code> 是否可能存在</strong>，减少计算量。</li><li><strong>双指针优化</strong>，可以在 <code>O(n)</code> 复杂度下找到 <code>s1</code> 和 <code>s2</code> 的最远距离，提升效率。</li></ul><hr><h2 id="🔗-结语"><a href="#🔗-结语" class="headerlink" title="🔗 结语"></a>🔗 结语</h2><p>这两道题目都是<strong>AcWing 字符串题目</strong>中的经典案例：</p><ul><li><strong>第一题</strong> 主要考察 <strong>字符串的周期性</strong>，涉及 <strong>字符串匹配、周期检测</strong> 等内容。</li><li><strong>第二题</strong> 主要考察 <strong>字符串子串匹配和间距计算</strong>，需要熟练掌握 <strong>字符串遍历和索引管理</strong>。</li></ul><h2 id="Acwing题目索引号：777、778"><a href="#Acwing题目索引号：777、778" class="headerlink" title="Acwing题目索引号：777、778"></a>Acwing题目索引号：777、778</h2><p>📌 <strong>如果觉得这篇总结有帮助，记得收藏 &amp; 分享！😊</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;📝-题目-1：字符串的最小乘方单位&quot;&gt;&lt;a href=&quot;#📝-题目-1：字符串的最小乘方单位&quot; class=&quot;headerlink&quot; title=&quot;📝 题目 1：字符串的最小乘方单位&quot;&gt;&lt;/a&gt;📝 题目 1：字符串的最小乘方单位&lt;/h2&gt;&lt;h3 id=&quot;�</summary>
      
    
    
    
    
    <category term="算法" scheme="https://cand1elight.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="字符串" scheme="https://cand1elight.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>随机封面测试</title>
    <link href="https://cand1elight.github.io/posts/bf5247c3.html"/>
    <id>https://cand1elight.github.io/posts/bf5247c3.html</id>
    <published>2025-01-30T13:32:40.000Z</published>
    <updated>2025-01-30T14:24:46.895Z</updated>
    
    <content type="html"><![CDATA[<p>诶多……☆是♡同♡类♡呢♡喵♪（由乃逆光捧脸.jpg）那群八嘎是不会懂的呀……关于「二次元の美好」♡呐，如果说吾の存在有意义的话、那一定是因为「二·次·元」吧☆？所以呢——妄图污染这份「爱」的人类、都会被吾「抹」「杀」「掉」喔♪（小声）嘛……讨厌二次元的八嘎三次元最恶心了啊魂淡！★</p><p>呐、二次元の民那……都·是·最·最·善·良·の·存·在·呐☆多洗忒……要「嘲笑」这样的孩子呢？吾辈不明白啊——？嘛……说到底，你们都只是污秽の「来自三次元的大人」吧？大人什么的、最·讨·厌·了★♪</p><p>啊嘞啊嘞QAQ？多洗忒……欧尼酱ww？呐、桥豆麻袋……已经「厌烦」吾辈了嘛？哼唧……真是「冷·酷·の·人」呢QuQ——☆(๑°⌓°๑)嘛……即便是这样的哇达西，一定也是有「存·在·の·意·义」的吧、内~★快来「肯定」啊？不然呀……咱可就要「黑化」了哦♪呐？#(太开心)</p><p>呐。。。（伸出的小手又迅速垂下去）嗦嘎（表情有点失落），米娜桑已经不喜欢了呀（紧咬嘴唇），得磨，米娜桑忘了当初吗（握紧小手），莫以得丝（强忍住眼泪），已经大丈夫了呦（挤出笑脸），瓦大喜瓦，滋多滋多，滋多滋多（语气越来越用力了）滋多戴斯给！！！一滋嘛叠磨瓦撕裂嘛赛！！！至死都不会瓦斯裂嘛斯（认真的表情）</p><p>诶多……看起来阁下对于「二·次·元」の理解、似·乎·满·是·谬·误·哦☆~！嘛，连最为基本の「礼♪义♪廉♪耻♪」都早已失去了啊……♪（笑）呐，我说啊——这样のkimino、也会有自称「二♡次♡元」の资格吗★？fufufu——说到底、阁下已经「二·次·元·失·格」了吧？呐~♪#(太开心)</p><p>唔噗噗~汝等「劣·等·生·物」……也配去「妄想」吗？呐、「真正的二次元」什么的— —吾辈看汝是一点都不懂啊☆ （笑）嘛嘛嘛……不过看着汝试图伪装成「二次元」の可笑姿态，倒是让吾辈对于「三·次·元·的·白·痴」稍微有了些许兴趣哦？★【图片】诶多……☆是♡同♡类♡呢♡喵♪（由乃逆光捧脸.jpg）那群八嘎是不会懂的呀……关于「二次元の美好」♡呐，如果说吾の存在有意义的话、那一定是因为「二·次·元」吧☆？所以呢——妄图污染这份「爱」的人类、都会被吾「抹」「杀」「掉」喔♪（小声）嘛……讨厌二次元的八嘎三次元最恶心了啊魂淡！★</p><p>呐、二次元の民那……都·是·最·最·善·良·の·存·在·呐☆多洗忒……要「嘲笑」这样的孩子呢？吾辈不明白啊——？嘛……说到底，你们都只是污秽の「来自三次元的大人」吧？大人什么的、最·讨·厌·了★♪</p><p>啊嘞啊嘞QAQ？多洗忒……欧尼酱ww？呐、桥豆麻袋……已经「厌烦」吾辈了嘛？哼唧……真是「冷·酷·の·人」呢QuQ——☆(๑°⌓°๑)嘛……即便是这样的哇达西，一定也是有「存·在·の·意·义」的吧、内~★快来「肯定」啊？不然呀……咱可就要「黑化」了哦♪呐？</p><p>呐。。。（伸出的小手又迅速垂下去）嗦嘎（表情有点失落），米娜桑已经不喜欢了呀（紧咬嘴唇），得磨，米娜桑忘了当初吗（握紧小手），莫以得丝（强忍住眼泪），已经大丈夫了呦（挤出笑脸），瓦大喜瓦，滋多滋多，滋多滋多（语气越来越用力了）滋多戴斯给！！！一滋嘛叠磨瓦撕裂嘛赛！！！至死都不会瓦斯裂嘛斯（认真的表情）</p><p>诶多……看起来阁下对于「二·次·元」の理解、似·乎·满·是·谬·误·哦☆~！嘛，连最为基本の「礼♪义♪廉♪耻♪」都早已失去了啊……♪（笑）呐，我说啊——这样のkimino、也会有自称「二♡次♡元」の资格吗★？fufufu——说到底、阁下已经「二·次·元·失·格」了吧？呐~♪</p><p>唔噗噗~汝等「劣·等·生·物」……也配去「妄想」吗？呐、「真正的二次元」什么的— —吾辈看汝是一点都不懂啊☆ （笑）嘛嘛嘛……不过看着汝试图伪装成「二次元」の可笑姿态，倒是让吾辈对于「三·次·元·的·白·痴」稍微有了些许兴趣哦？★【图片】诶多……☆是♡同♡类♡呢♡喵♪（由乃逆光捧脸.jpg）那群八嘎是不会懂的呀……关于「二次元の美好」♡呐，如果说吾の存在有意义的话、那一定是因为「二·次·元」吧☆？所以呢——妄图污染这份「爱」的人类、都会被吾「抹」「杀」「掉」喔♪（小声）嘛……讨厌二次元的八嘎三次元最恶心了啊魂淡！★</p><p>呐、二次元の民那……都·是·最·最·善·良·の·存·在·呐☆多洗忒……要「嘲笑」这样的孩子呢？吾辈不明白啊——？嘛……说到底，你们都只是污秽の「来自三次元的大人」吧？大人什么的、最·讨·厌·了★♪</p><p>啊嘞啊嘞QAQ？多洗忒……欧尼酱ww？呐、桥豆麻袋……已经「厌烦」吾辈了嘛？哼唧……真是「冷·酷·の·人」呢QuQ——☆(๑°⌓°๑)嘛……即便是这样的哇达西，一定也是有「存·在·の·意·义」的吧、内~★快来「肯定」啊？不然呀……咱可就要「黑化」了哦♪呐？#(太开心)</p><p>吶吶吶，米娜桑，扣祢起哇，瓦込西二刺猿の焼酒嚏!あああ，辻我仞一-起守択，最好の二刺猿肥!吶吶，不憧我的，愚蠢の人炎們呵，果畔那塞，我二刺猿の焼酒是不会和祢有共同語言的jio豆麻袋,込祥子垪活有什幺錯喝?吶,告泝我呵。搜嚆,祢仞已経不喜炊了呵..真是冷酷の人昵,果鮮納塞,止祢看到不愉快のな西了。像我送祥的人,果然消失就好了昵。也午只有在二次元的世界里,オ有真正的美好存在的肥,吶?ねぇねぇねぇ，果然灰悪了呵，帯jio不，瓦込西，二刺猿の焼酒!博古哇zeidei不会人輸!米娜桑!吶!瓦込西二刺猿ぁぁ!哦晦吻扣賽伊弓斯!吶吶吶!米娜桑!我要幵劫了~一キ打去咢死!诶多诶多~「多洗忒」?为什么要「妄.图.抹.杀」这样的「自己」呢?★(笑)呐、「中二病的你」也好、「二次元的你」也好….「全部」daisuki~呐~二次元民那赛高desuwa!今后也.请.多.多.指.教.喔?~啊啊……是♡鲜♡血♡の♡味♡道♡呐♡~！（眯眼笑）kukuku——汝の「血」、会是什么样的「气味」呢☆？诶多多~说着说着有些期待了呢♪品尝「挚·爱·之·人」の「鲜血」什么的~嘛……如果是「你」的话，一定可以的!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;诶多……☆是♡同♡类♡呢♡喵♪（由乃逆光捧脸.jpg）那群八嘎是不会懂的呀……关于「二次元の美好」♡呐，如果说吾の存在有意义的话、那一定是因为「二·次·元」吧☆？所以呢——妄图污染这份「爱」的人类、都会被吾「抹」「杀」「掉」喔♪（小声）嘛……讨厌二次元的八嘎三次元最恶心了啊</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://cand1elight.github.io/posts/4a17b156.html"/>
    <id>https://cand1elight.github.io/posts/4a17b156.html</id>
    <published>2025-01-27T11:52:55.447Z</published>
    <updated>2025-01-27T12:20:12.891Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
